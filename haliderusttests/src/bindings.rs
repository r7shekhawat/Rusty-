/* automatically generated by rust-bindgen 0.55.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 34;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn halide_print(
        user_context: *mut ::std::os::raw::c_void,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn halide_default_print(
        user_context: *mut ::std::os::raw::c_void,
        arg1: *const ::std::os::raw::c_char,
    );
}
pub type halide_print_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn halide_set_custom_print(print: halide_print_t) -> halide_print_t;
}
extern "C" {
    pub fn halide_error(
        user_context: *mut ::std::os::raw::c_void,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn halide_default_error(
        user_context: *mut ::std::os::raw::c_void,
        arg1: *const ::std::os::raw::c_char,
    );
}
pub type halide_error_handler_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn halide_set_error_handler(handler: halide_error_handler_t) -> halide_error_handler_t;
}
#[doc = " Cross-platform mutex. Must be initialized with zero and implementation"]
#[doc = " must treat zero as an unlocked mutex with no waiters, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_mutex {
    pub _private: [usize; 1usize],
}
#[test]
fn bindgen_test_layout_halide_mutex() {
    assert_eq!(
        ::std::mem::size_of::<halide_mutex>(),
        8usize,
        concat!("Size of: ", stringify!(halide_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_mutex>()))._private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_mutex),
            "::",
            stringify!(_private)
        )
    );
}
#[doc = " Cross platform condition variable. Must be initialized to 0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_cond {
    pub _private: [usize; 1usize],
}
#[test]
fn bindgen_test_layout_halide_cond() {
    assert_eq!(
        ::std::mem::size_of::<halide_cond>(),
        8usize,
        concat!("Size of: ", stringify!(halide_cond))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_cond>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_cond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_cond>()))._private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_cond),
            "::",
            stringify!(_private)
        )
    );
}
extern "C" {
    pub fn halide_mutex_lock(mutex: *mut halide_mutex);
}
extern "C" {
    pub fn halide_mutex_unlock(mutex: *mut halide_mutex);
}
extern "C" {
    pub fn halide_cond_signal(cond: *mut halide_cond);
}
extern "C" {
    pub fn halide_cond_broadcast(cond: *mut halide_cond);
}
extern "C" {
    pub fn halide_cond_wait(cond: *mut halide_cond, mutex: *mut halide_mutex);
}
#[doc = " Functions for constructing/destroying/locking/unlocking arrays of mutexes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_mutex_array {
    _unused: [u8; 0],
}
extern "C" {
    pub fn halide_mutex_array_create(sz: ::std::os::raw::c_int) -> *mut halide_mutex_array;
}
extern "C" {
    pub fn halide_mutex_array_destroy(
        user_context: *mut ::std::os::raw::c_void,
        array: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn halide_mutex_array_lock(
        array: *mut halide_mutex_array,
        entry: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_mutex_array_unlock(
        array: *mut halide_mutex_array,
        entry: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type halide_task_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_context: *mut ::std::os::raw::c_void,
        task_number: ::std::os::raw::c_int,
        closure: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn halide_do_par_for(
        user_context: *mut ::std::os::raw::c_void,
        task: halide_task_t,
        min: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        closure: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_shutdown_thread_pool();
}
#[doc = " Set a custom method for performing a parallel for loop. Returns"]
#[doc = " the old do_par_for handler."]
pub type halide_do_par_for_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: halide_task_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn halide_set_custom_do_par_for(do_par_for: halide_do_par_for_t) -> halide_do_par_for_t;
}
#[doc = " An opaque struct representing a semaphore. Used by the task system for async tasks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_semaphore_t {
    pub _private: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_halide_semaphore_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_semaphore_t>(),
        16usize,
        concat!("Size of: ", stringify!(halide_semaphore_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_semaphore_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_semaphore_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_semaphore_t>()))._private as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_semaphore_t),
            "::",
            stringify!(_private)
        )
    );
}
#[doc = " A struct representing a semaphore and a number of items that must"]
#[doc = " be acquired from it. Used in halide_parallel_task_t below."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_semaphore_acquire_t {
    pub semaphore: *mut halide_semaphore_t,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_halide_semaphore_acquire_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_semaphore_acquire_t>(),
        16usize,
        concat!("Size of: ", stringify!(halide_semaphore_acquire_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_semaphore_acquire_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_semaphore_acquire_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_semaphore_acquire_t>())).semaphore as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_semaphore_acquire_t),
            "::",
            stringify!(semaphore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_semaphore_acquire_t>())).count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_semaphore_acquire_t),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    pub fn halide_semaphore_init(
        arg1: *mut halide_semaphore_t,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_semaphore_release(
        arg1: *mut halide_semaphore_t,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_semaphore_try_acquire(
        arg1: *mut halide_semaphore_t,
        n: ::std::os::raw::c_int,
    ) -> bool;
}
pub type halide_semaphore_init_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut halide_semaphore_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type halide_semaphore_release_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut halide_semaphore_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type halide_semaphore_try_acquire_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut halide_semaphore_t, arg2: ::std::os::raw::c_int) -> bool,
>;
#[doc = " A task representing a serial for loop evaluated over some range."]
#[doc = " Note that task_parent is a pass through argument that should be"]
#[doc = " passed to any dependent taks that are invoked using halide_do_parallel_tasks"]
#[doc = " underneath this call."]
pub type halide_loop_task_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_context: *mut ::std::os::raw::c_void,
        min: ::std::os::raw::c_int,
        extent: ::std::os::raw::c_int,
        closure: *mut u8,
        task_parent: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A parallel task to be passed to halide_do_parallel_tasks. This"]
#[doc = " task may recursively call halide_do_parallel_tasks, and there may"]
#[doc = " be complex dependencies between seemingly unrelated tasks expressed"]
#[doc = " using semaphores. If you are using a custom task system, care must"]
#[doc = " be taken to avoid potential deadlock. This can be done by carefully"]
#[doc = " respecting the static metadata at the end of the task struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_parallel_task_t {
    pub fn_: halide_loop_task_t,
    pub closure: *mut u8,
    pub name: *const ::std::os::raw::c_char,
    pub semaphores: *mut halide_semaphore_acquire_t,
    pub num_semaphores: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub extent: ::std::os::raw::c_int,
    pub min_threads: ::std::os::raw::c_int,
    pub serial: bool,
}
#[test]
fn bindgen_test_layout_halide_parallel_task_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_parallel_task_t>(),
        56usize,
        concat!("Size of: ", stringify!(halide_parallel_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_parallel_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_parallel_task_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_parallel_task_t>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_parallel_task_t>())).closure as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_parallel_task_t>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_parallel_task_t>())).semaphores as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(semaphores)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_parallel_task_t>())).num_semaphores as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(num_semaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_parallel_task_t>())).min as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_parallel_task_t>())).extent as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_parallel_task_t>())).min_threads as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(min_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_parallel_task_t>())).serial as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_parallel_task_t),
            "::",
            stringify!(serial)
        )
    );
}
extern "C" {
    #[doc = " Enqueue some number of the tasks described above and wait for them"]
    #[doc = " to complete. While waiting, the calling threads assists with either"]
    #[doc = " the tasks enqueued, or other non-blocking tasks in the task"]
    #[doc = " system. Note that task_parent should be NULL for top-level calls"]
    #[doc = " and the pass through argument if this call is being made from"]
    #[doc = " another task."]
    pub fn halide_do_parallel_tasks(
        user_context: *mut ::std::os::raw::c_void,
        num_tasks: ::std::os::raw::c_int,
        tasks: *mut halide_parallel_task_t,
        task_parent: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type halide_do_task_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: halide_task_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn halide_set_custom_do_task(do_task: halide_do_task_t) -> halide_do_task_t;
}
extern "C" {
    pub fn halide_do_task(
        user_context: *mut ::std::os::raw::c_void,
        f: halide_task_t,
        idx: ::std::os::raw::c_int,
        closure: *mut u8,
    ) -> ::std::os::raw::c_int;
}
pub type halide_do_loop_task_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: halide_loop_task_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut u8,
        arg6: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn halide_set_custom_do_loop_task(do_task: halide_do_loop_task_t) -> halide_do_loop_task_t;
}
extern "C" {
    pub fn halide_do_loop_task(
        user_context: *mut ::std::os::raw::c_void,
        f: halide_loop_task_t,
        min: ::std::os::raw::c_int,
        extent: ::std::os::raw::c_int,
        closure: *mut u8,
        task_parent: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type halide_do_parallel_tasks_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut halide_parallel_task_t,
        task_parent: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn halide_set_custom_parallel_runtime(
        arg1: halide_do_par_for_t,
        arg2: halide_do_task_t,
        arg3: halide_do_loop_task_t,
        arg4: halide_do_parallel_tasks_t,
        arg5: halide_semaphore_init_t,
        arg6: halide_semaphore_try_acquire_t,
        arg7: halide_semaphore_release_t,
    );
}
extern "C" {
    pub fn halide_default_do_par_for(
        user_context: *mut ::std::os::raw::c_void,
        task: halide_task_t,
        min: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        closure: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_default_do_parallel_tasks(
        user_context: *mut ::std::os::raw::c_void,
        num_tasks: ::std::os::raw::c_int,
        tasks: *mut halide_parallel_task_t,
        task_parent: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_default_do_task(
        user_context: *mut ::std::os::raw::c_void,
        f: halide_task_t,
        idx: ::std::os::raw::c_int,
        closure: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_default_do_loop_task(
        user_context: *mut ::std::os::raw::c_void,
        f: halide_loop_task_t,
        min: ::std::os::raw::c_int,
        extent: ::std::os::raw::c_int,
        closure: *mut u8,
        task_parent: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_default_semaphore_init(
        arg1: *mut halide_semaphore_t,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_default_semaphore_release(
        arg1: *mut halide_semaphore_t,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_default_semaphore_try_acquire(
        arg1: *mut halide_semaphore_t,
        n: ::std::os::raw::c_int,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_thread {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Spawn a thread. Returns a handle to the thread for the purposes of"]
    #[doc = " joining it. The thread must be joined in order to clean up any"]
    #[doc = " resources associated with it."]
    pub fn halide_spawn_thread(
        f: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        closure: *mut ::std::os::raw::c_void,
    ) -> *mut halide_thread;
}
extern "C" {
    #[doc = " Join a thread."]
    pub fn halide_join_thread(arg1: *mut halide_thread);
}
extern "C" {
    #[doc = " Set the number of threads used by Halide's thread pool. Returns"]
    #[doc = " the old number."]
    #[doc = ""]
    #[doc = " n < 0  : error condition"]
    #[doc = " n == 0 : use a reasonable system default (typically, number of cpus online)."]
    #[doc = " n == 1 : use exactly one thread; this will always enforce serial execution"]
    #[doc = " n > 1  : use a pool of exactly n threads."]
    #[doc = ""]
    #[doc = " (Note that this is only guaranteed when using the default implementations"]
    #[doc = " of halide_do_par_for(); custom implementations may completely ignore values"]
    #[doc = " passed to halide_set_num_threads().)"]
    pub fn halide_set_num_threads(n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_malloc(
        user_context: *mut ::std::os::raw::c_void,
        x: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_free(user_context: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn halide_default_malloc(
        user_context: *mut ::std::os::raw::c_void,
        x: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_default_free(
        user_context: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
    );
}
pub type halide_malloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type halide_free_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn halide_set_custom_malloc(user_malloc: halide_malloc_t) -> halide_malloc_t;
}
extern "C" {
    pub fn halide_set_custom_free(user_free: halide_free_t) -> halide_free_t;
}
extern "C" {
    pub fn halide_get_symbol(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_load_library(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_get_library_symbol(
        lib: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_default_get_symbol(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_default_load_library(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn halide_default_get_library_symbol(
        lib: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
pub type halide_get_symbol_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
pub type halide_load_library_t = ::std::option::Option<
    unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
pub type halide_get_library_symbol_t = ::std::option::Option<
    unsafe extern "C" fn(
        lib: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn halide_set_custom_get_symbol(
        user_get_symbol: halide_get_symbol_t,
    ) -> halide_get_symbol_t;
}
extern "C" {
    pub fn halide_set_custom_load_library(
        user_load_library: halide_load_library_t,
    ) -> halide_load_library_t;
}
extern "C" {
    pub fn halide_set_custom_get_library_symbol(
        user_get_library_symbol: halide_get_library_symbol_t,
    ) -> halide_get_library_symbol_t;
}
extern "C" {
    #[doc = " Called when debug_to_file is used inside %Halide code.  See"]
    #[doc = " Func::debug_to_file for how this is called"]
    #[doc = ""]
    #[doc = " Cannot be replaced in JITted code at present."]
    pub fn halide_debug_to_file(
        user_context: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        type_code: i32,
        buf: *mut halide_buffer_t,
    ) -> i32;
}
#[doc = "< signed integers"]
pub const halide_type_code_t_halide_type_int: halide_type_code_t = 0;
#[doc = "< unsigned integers"]
pub const halide_type_code_t_halide_type_uint: halide_type_code_t = 1;
#[doc = "< IEEE floating point numbers"]
pub const halide_type_code_t_halide_type_float: halide_type_code_t = 2;
#[doc = "< opaque pointer type (void *)"]
pub const halide_type_code_t_halide_type_handle: halide_type_code_t = 3;
#[doc = "< floating point numbers in the bfloat format"]
pub const halide_type_code_t_halide_type_bfloat: halide_type_code_t = 4;
#[doc = " Types in the halide type system. They can be ints, unsigned ints,"]
#[doc = " or floats (of various bit-widths), or a handle (which is always 64-bits)."]
#[doc = " Note that the int/uint/float values do not imply a specific bit width"]
#[doc = " (the bit width is expected to be encoded in a separate value)."]
pub type halide_type_code_t = ::std::os::raw::c_uint;
#[doc = " A runtime tag for a type in the halide type system. Can be ints,"]
#[doc = " unsigned ints, or floats of various bit-widths (the 'bits'"]
#[doc = " field). Can also be vectors of the same (by setting the 'lanes'"]
#[doc = " field to something larger than one). This struct should be"]
#[doc = " exactly 32-bits in size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_type_t {
    pub code: u8,
    #[doc = " The number of bits of precision of a single scalar value of this type."]
    pub bits: u8,
    #[doc = " How many elements in a vector. This is 1 for scalar types."]
    pub lanes: u16,
}
#[test]
fn bindgen_test_layout_halide_type_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_type_t>(),
        4usize,
        concat!("Size of: ", stringify!(halide_type_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_type_t>(),
        2usize,
        concat!("Alignment of ", stringify!(halide_type_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_type_t>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_type_t),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_type_t>())).bits as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_type_t),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_type_t>())).lanes as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_type_t),
            "::",
            stringify!(lanes)
        )
    );
}
pub const halide_trace_event_code_t_halide_trace_load: halide_trace_event_code_t = 0;
pub const halide_trace_event_code_t_halide_trace_store: halide_trace_event_code_t = 1;
pub const halide_trace_event_code_t_halide_trace_begin_realization: halide_trace_event_code_t = 2;
pub const halide_trace_event_code_t_halide_trace_end_realization: halide_trace_event_code_t = 3;
pub const halide_trace_event_code_t_halide_trace_produce: halide_trace_event_code_t = 4;
pub const halide_trace_event_code_t_halide_trace_end_produce: halide_trace_event_code_t = 5;
pub const halide_trace_event_code_t_halide_trace_consume: halide_trace_event_code_t = 6;
pub const halide_trace_event_code_t_halide_trace_end_consume: halide_trace_event_code_t = 7;
pub const halide_trace_event_code_t_halide_trace_begin_pipeline: halide_trace_event_code_t = 8;
pub const halide_trace_event_code_t_halide_trace_end_pipeline: halide_trace_event_code_t = 9;
pub const halide_trace_event_code_t_halide_trace_tag: halide_trace_event_code_t = 10;
pub type halide_trace_event_code_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_trace_event_t {
    #[doc = " The name of the Func or Pipeline that this event refers to"]
    pub func: *const ::std::os::raw::c_char,
    #[doc = " If the event type is a load or a store, this points to the"]
    #[doc = " value being loaded or stored. Use the type field to safely cast"]
    #[doc = " this to a concrete pointer type and retrieve it. For other"]
    #[doc = " events this is null."]
    pub value: *mut ::std::os::raw::c_void,
    #[doc = " For loads and stores, an array which contains the location"]
    #[doc = " being accessed. For vector loads or stores it is an array of"]
    #[doc = " vectors of coordinates (the vector dimension is innermost)."]
    #[doc = ""]
    #[doc = " For realization or production-related events, this will contain"]
    #[doc = " the mins and extents of the region being accessed, in the order"]
    #[doc = " min0, extent0, min1, extent1, ..."]
    #[doc = ""]
    #[doc = " For pipeline-related events, this will be null."]
    pub coordinates: *mut i32,
    #[doc = " For halide_trace_tag, this points to a read-only null-terminated string"]
    #[doc = " of arbitrary text. For all other events, this will be null."]
    pub trace_tag: *const ::std::os::raw::c_char,
    #[doc = " If the event type is a load or a store, this is the type of"]
    #[doc = " the data. Otherwise, the value is meaningless."]
    pub type_: halide_type_t,
    #[doc = " The type of event"]
    pub event: halide_trace_event_code_t,
    pub parent_id: i32,
    #[doc = " If this was a load or store of a Tuple-valued Func, this is"]
    #[doc = " which tuple element was accessed."]
    pub value_index: i32,
    #[doc = " The length of the coordinates array"]
    pub dimensions: i32,
}
#[test]
fn bindgen_test_layout_halide_trace_event_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_trace_event_t>(),
        56usize,
        concat!("Size of: ", stringify!(halide_trace_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_trace_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_trace_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_trace_event_t>())).coordinates as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(coordinates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).trace_tag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(trace_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).event as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).parent_id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_trace_event_t>())).value_index as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(value_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_event_t>())).dimensions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_event_t),
            "::",
            stringify!(dimensions)
        )
    );
}
extern "C" {
    pub fn halide_trace(
        user_context: *mut ::std::os::raw::c_void,
        event: *const halide_trace_event_t,
    ) -> i32;
}
extern "C" {
    pub fn halide_default_trace(
        user_context: *mut ::std::os::raw::c_void,
        event: *const halide_trace_event_t,
    ) -> i32;
}
pub type halide_trace_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_context: *mut ::std::os::raw::c_void,
        arg1: *const halide_trace_event_t,
    ) -> i32,
>;
extern "C" {
    pub fn halide_set_custom_trace(trace: halide_trace_t) -> halide_trace_t;
}
#[doc = " The header of a packet in a binary trace. All fields are 32-bit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_trace_packet_t {
    #[doc = " The total size of this packet in bytes. Always a multiple of"]
    #[doc = " four. Equivalently, the number of bytes until the next"]
    #[doc = " packet."]
    pub size: u32,
    #[doc = " The id of this packet (for the purpose of parent_id)."]
    pub id: i32,
    pub type_: halide_type_t,
    pub event: halide_trace_event_code_t,
    pub parent_id: i32,
    pub value_index: i32,
    pub dimensions: i32,
}
#[test]
fn bindgen_test_layout_halide_trace_packet_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_trace_packet_t>(),
        28usize,
        concat!("Size of: ", stringify!(halide_trace_packet_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_trace_packet_t>(),
        4usize,
        concat!("Alignment of ", stringify!(halide_trace_packet_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_packet_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_packet_t>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_packet_t>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_packet_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_trace_packet_t>())).parent_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(parent_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_trace_packet_t>())).value_index as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(value_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_trace_packet_t>())).dimensions as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_trace_packet_t),
            "::",
            stringify!(dimensions)
        )
    );
}
extern "C" {
    #[doc = " Set the file descriptor that Halide should write binary trace"]
    #[doc = " events to. If called with 0 as the argument, Halide outputs trace"]
    #[doc = " information to stdout in a human-readable format. If never called,"]
    #[doc = " Halide checks the for existence of an environment variable called"]
    #[doc = " HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined,"]
    #[doc = " it outputs trace information to stdout in a human-readable"]
    #[doc = " format."]
    pub fn halide_set_trace_file(fd: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Halide calls this to retrieve the file descriptor to write binary"]
    #[doc = " trace events to. The default implementation returns the value set"]
    #[doc = " by halide_set_trace_file. Implement it yourself if you wish to use"]
    #[doc = " a custom file descriptor per user_context. Return zero from your"]
    #[doc = " implementation to tell Halide to print human-readable trace"]
    #[doc = " information to stdout."]
    pub fn halide_get_trace_file(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If tracing is writing to a file. This call closes that file"]
    #[doc = " (flushing the trace). Returns zero on success."]
    pub fn halide_shutdown_trace() -> ::std::os::raw::c_int;
}
#[doc = " An opaque struct containing per-GPU API implementations of the"]
#[doc = " device functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_device_interface_impl_t {
    _unused: [u8; 0],
}
#[doc = " Each GPU API provides a halide_device_interface_t struct pointing"]
#[doc = " to the code that manages device allocations. You can access these"]
#[doc = " functions directly from the struct member function pointers, or by"]
#[doc = " calling the functions declared below. Note that the global"]
#[doc = " functions are not available when using Halide as a JIT compiler."]
#[doc = " If you are using raw halide_buffer_t in that context you must use"]
#[doc = " the function pointers in the device_interface struct."]
#[doc = ""]
#[doc = " The function pointers below are currently the same for every GPU"]
#[doc = " API; only the impl field varies. These top-level functions do the"]
#[doc = " bookkeeping that is common across all GPU APIs, and then dispatch"]
#[doc = " to more API-specific functions via another set of function pointers"]
#[doc = " hidden inside the impl field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_device_interface_t {
    pub device_malloc: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
            device_interface: *const halide_device_interface_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_free: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_sync: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_release: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            device_interface: *const halide_device_interface_t,
        ),
    >,
    pub copy_to_host: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub copy_to_device: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
            device_interface: *const halide_device_interface_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_and_host_malloc: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
            device_interface: *const halide_device_interface_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_and_host_free: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub buffer_copy: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            src: *mut halide_buffer_t,
            dst_device_interface: *const halide_device_interface_t,
            dst: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_crop: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            src: *const halide_buffer_t,
            dst: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_slice: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            src: *const halide_buffer_t,
            slice_dim: ::std::os::raw::c_int,
            slice_pos: ::std::os::raw::c_int,
            dst: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub device_release_crop: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub wrap_native: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
            handle: u64,
            device_interface: *const halide_device_interface_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub detach_native: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            buf: *mut halide_buffer_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub compute_capability: ::std::option::Option<
        unsafe extern "C" fn(
            user_context: *mut ::std::os::raw::c_void,
            major: *mut ::std::os::raw::c_int,
            minor: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub impl_: *const halide_device_interface_impl_t,
}
#[test]
fn bindgen_test_layout_halide_device_interface_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_device_interface_t>(),
        128usize,
        concat!("Size of: ", stringify!(halide_device_interface_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_device_interface_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_device_interface_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_malloc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_malloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_free as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_sync as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_release as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).copy_to_host as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(copy_to_host)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).copy_to_device as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(copy_to_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_and_host_malloc as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_and_host_malloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_and_host_free as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_and_host_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).buffer_copy as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(buffer_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_crop as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_crop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_slice as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_slice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).device_release_crop as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(device_release_crop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).wrap_native as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(wrap_native)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).detach_native as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(detach_native)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_interface_t>())).compute_capability as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(compute_capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_device_interface_t>())).impl_ as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_interface_t),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Release all data associated with the given device interface, in"]
    #[doc = " particular all resources (memory, texture, context handles)"]
    #[doc = " allocated by Halide. Must be called explicitly when using AOT"]
    #[doc = " compilation. This is *not* thread-safe with respect to actively"]
    #[doc = " running Halide code. Ensure all pipelines are finished before"]
    #[doc = " calling this."]
    pub fn halide_device_release(
        user_context: *mut ::std::os::raw::c_void,
        device_interface: *const halide_device_interface_t,
    );
}
extern "C" {
    #[doc = " Copy image data from device memory to host memory. This must be called"]
    #[doc = " explicitly to copy back the results of a GPU-based filter."]
    pub fn halide_copy_to_host(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy image data from host memory to device memory. This should not"]
    #[doc = " be called directly; Halide handles copying to the device"]
    #[doc = " automatically.  If interface is NULL and the buf has a non-zero dev"]
    #[doc = " field, the device associated with the dev handle will be"]
    #[doc = " used. Otherwise if the dev field is 0 and interface is NULL, an"]
    #[doc = " error is returned."]
    pub fn halide_copy_to_device(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
        device_interface: *const halide_device_interface_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy data from one buffer to another. The buffers may have"]
    #[doc = " different shapes and sizes, but the destination buffer's shape must"]
    #[doc = " be contained within the source buffer's shape. That is, for each"]
    #[doc = " dimension, the min on the destination buffer must be greater than"]
    #[doc = " or equal to the min on the source buffer, and min+extent on the"]
    #[doc = " destination buffer must be less that or equal to min+extent on the"]
    #[doc = " source buffer. The source data is pulled from either device or"]
    #[doc = " host memory on the source, depending on the dirty flags. host is"]
    #[doc = " preferred if both are valid. The dst_device_interface parameter"]
    #[doc = " controls the destination memory space. NULL means host memory."]
    pub fn halide_buffer_copy(
        user_context: *mut ::std::os::raw::c_void,
        src: *mut halide_buffer_t,
        dst_device_interface: *const halide_device_interface_t,
        dst: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Give the destination buffer a device allocation which is an alias"]
    #[doc = " for the same coordinate range in the source buffer. Modifies the"]
    #[doc = " device, device_interface, and the device_dirty flag only. Only"]
    #[doc = " supported by some device APIs (others will return"]
    #[doc = " halide_error_code_device_crop_unsupported). Call"]
    #[doc = " halide_device_release_crop instead of halide_device_free to clean"]
    #[doc = " up resources associated with the cropped view. Do not free the"]
    #[doc = " device allocation on the source buffer while the destination buffer"]
    #[doc = " still lives. Note that the two buffers do not share dirty flags, so"]
    #[doc = " care must be taken to update them together as needed. Note that src"]
    #[doc = " and dst are required to have the same number of dimensions."]
    #[doc = ""]
    #[doc = " Note also that (in theory) device interfaces which support cropping may"]
    #[doc = " still not support cropping a crop (instead, create a new crop of the parent"]
    #[doc = " buffer); in practice, no known implementation has this limitation, although"]
    #[doc = " it is possible that some future implementations may require it."]
    pub fn halide_device_crop(
        user_context: *mut ::std::os::raw::c_void,
        src: *const halide_buffer_t,
        dst: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Give the destination buffer a device allocation which is an alias"]
    #[doc = " for a similar coordinate range in the source buffer, but with one dimension"]
    #[doc = " sliced away in the dst. Modifies the device, device_interface, and the"]
    #[doc = " device_dirty flag only. Only supported by some device APIs (others will return"]
    #[doc = " halide_error_code_device_crop_unsupported). Call"]
    #[doc = " halide_device_release_crop instead of halide_device_free to clean"]
    #[doc = " up resources associated with the sliced view. Do not free the"]
    #[doc = " device allocation on the source buffer while the destination buffer"]
    #[doc = " still lives. Note that the two buffers do not share dirty flags, so"]
    #[doc = " care must be taken to update them together as needed. Note that the dst buffer"]
    #[doc = " must have exactly one fewer dimension than the src buffer, and that slice_dim"]
    #[doc = " and slice_pos must be valid within src."]
    pub fn halide_device_slice(
        user_context: *mut ::std::os::raw::c_void,
        src: *const halide_buffer_t,
        slice_dim: ::std::os::raw::c_int,
        slice_pos: ::std::os::raw::c_int,
        dst: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release any resources associated with a cropped/sliced view of another"]
    #[doc = " buffer."]
    pub fn halide_device_release_crop(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for current GPU operations to complete. Calling this explicitly"]
    #[doc = " should rarely be necessary, except maybe for profiling."]
    pub fn halide_device_sync(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate device memory to back a halide_buffer_t."]
    pub fn halide_device_malloc(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
        device_interface: *const halide_device_interface_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free device memory."]
    pub fn halide_device_free(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_device_wrap_native(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
        handle: u64,
        device_interface: *const halide_device_interface_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_device_detach_native(
        user_context: *mut ::std::os::raw::c_void,
        buf: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Selects which gpu device to use. 0 is usually the display"]
    #[doc = " device. If never called, Halide uses the environment variable"]
    #[doc = " HL_GPU_DEVICE. If that variable is unset, Halide uses the last"]
    #[doc = " device. Set this to -1 to use the last device."]
    pub fn halide_set_gpu_device(n: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Halide calls this to get the desired halide gpu device"]
    #[doc = " setting. Implement this yourself to use a different gpu device per"]
    #[doc = " user_context. The default implementation returns the value set by"]
    #[doc = " halide_set_gpu_device, or the environment variable"]
    #[doc = " HL_GPU_DEVICE."]
    pub fn halide_get_gpu_device(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the soft maximum amount of memory, in bytes, that the LRU"]
    #[doc = "  cache will use to memoize Func results.  This is not a strict"]
    #[doc = "  maximum in that concurrency and simultaneous use of memoized"]
    #[doc = "  reults larger than the cache size can both cause it to"]
    #[doc = "  temporariliy be larger than the size specified here."]
    pub fn halide_memoization_cache_set_size(size: i64);
}
extern "C" {
    #[doc = " Given a cache key for a memoized result, currently constructed"]
    #[doc = "  from the Func name and top-level Func name plus the arguments of"]
    #[doc = "  the computation, determine if the result is in the cache and"]
    #[doc = "  return it if so. (The internals of the cache key should be"]
    #[doc = "  considered opaque by this function.) If this routine returns true,"]
    #[doc = "  it is a cache miss. Otherwise, it will return false and the"]
    #[doc = "  buffers passed in will be filled, via copying, with memoized"]
    #[doc = "  data. The last argument is a list if halide_buffer_t pointers which"]
    #[doc = "  represents the outputs of the memoized Func. If the Func does not"]
    #[doc = "  return a Tuple, there will only be one halide_buffer_t in the list. The"]
    #[doc = "  tuple_count parameters determines the length of the list."]
    #[doc = ""]
    #[doc = " The return values are:"]
    #[doc = " -1: Signals an error."]
    #[doc = "  0: Success and cache hit."]
    #[doc = "  1: Success and cache miss."]
    pub fn halide_memoization_cache_lookup(
        user_context: *mut ::std::os::raw::c_void,
        cache_key: *const u8,
        size: i32,
        realized_bounds: *mut halide_buffer_t,
        tuple_count: i32,
        tuple_buffers: *mut *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a cache key for a memoized result, currently constructed"]
    #[doc = "  from the Func name and top-level Func name plus the arguments of"]
    #[doc = "  the computation, store the result in the cache for futre access by"]
    #[doc = "  halide_memoization_cache_lookup. (The internals of the cache key"]
    #[doc = "  should be considered opaque by this function.) Data is copied out"]
    #[doc = "  from the inputs and inputs are unmodified. The last argument is a"]
    #[doc = "  list if halide_buffer_t pointers which represents the outputs of the"]
    #[doc = "  memoized Func. If the Func does not return a Tuple, there will"]
    #[doc = "  only be one halide_buffer_t in the list. The tuple_count parameters"]
    #[doc = "  determines the length of the list."]
    #[doc = ""]
    #[doc = " If there is a memory allocation failure, the store does not store"]
    #[doc = " the data into the cache."]
    #[doc = ""]
    #[doc = " If has_eviction_key is true, the entry is marked with eviction_key to"]
    #[doc = " allow removing the key with halide_memoization_cache_evict."]
    pub fn halide_memoization_cache_store(
        user_context: *mut ::std::os::raw::c_void,
        cache_key: *const u8,
        size: i32,
        realized_bounds: *mut halide_buffer_t,
        tuple_count: i32,
        tuple_buffers: *mut *mut halide_buffer_t,
        has_eviction_key: bool,
        eviction_key: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Evict all cache entries that were tagged with the given"]
    #[doc = "  eviction_key in the memoize scheduling directive."]
    pub fn halide_memoization_cache_evict(
        user_context: *mut ::std::os::raw::c_void,
        eviction_key: u64,
    );
}
extern "C" {
    #[doc = " If halide_memoization_cache_lookup succeeds,"]
    #[doc = " halide_memoization_cache_release must be called to signal the"]
    #[doc = " storage is no longer being used by the caller. It will be passed"]
    #[doc = " the host pointer of one the buffers returned by"]
    #[doc = " halide_memoization_cache_lookup. That is"]
    #[doc = " halide_memoization_cache_release will be called multiple times for"]
    #[doc = " the case where halide_memoization_cache_lookup is handling multiple"]
    #[doc = " buffers.  (This corresponds to memoizing a Tuple in Halide.) Note"]
    #[doc = " that the host pointer must be sufficient to get to all information"]
    #[doc = " the release operation needs. The default Halide cache impleemntation"]
    #[doc = " accomplishes this by storing extra data before the start of the user"]
    #[doc = " modifiable host storage."]
    #[doc = ""]
    #[doc = " This call is like free and does not have a failure return."]
    pub fn halide_memoization_cache_release(
        user_context: *mut ::std::os::raw::c_void,
        host: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Free all memory and resources associated with the memoization cache."]
    #[doc = " Must be called at a time when no other threads are accessing the cache."]
    pub fn halide_memoization_cache_cleanup();
}
extern "C" {
    #[doc = " Verify that a given range of memory has been initialized; only used when Target::MSAN is enabled."]
    #[doc = ""]
    #[doc = " The default implementation simply calls the LLVM-provided __msan_check_mem_is_initialized() function."]
    #[doc = ""]
    #[doc = " The return value should always be zero."]
    pub fn halide_msan_check_memory_is_initialized(
        user_context: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        len: u64,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify that the data pointed to by the halide_buffer_t is initialized (but *not* the halide_buffer_t itself),"]
    #[doc = " using halide_msan_check_memory_is_initialized() for checking."]
    #[doc = ""]
    #[doc = " The default implementation takes pains to only check the active memory ranges"]
    #[doc = " (skipping padding), and sorting into ranges to always check the smallest number of"]
    #[doc = " ranges, in monotonically increasing memory order."]
    #[doc = ""]
    #[doc = " Most client code should never need to replace the default implementation."]
    #[doc = ""]
    #[doc = " The return value should always be zero."]
    pub fn halide_msan_check_buffer_is_initialized(
        user_context: *mut ::std::os::raw::c_void,
        buffer: *mut halide_buffer_t,
        buf_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Annotate that a given range of memory has been initialized;"]
    #[doc = " only used when Target::MSAN is enabled."]
    #[doc = ""]
    #[doc = " The default implementation simply calls the LLVM-provided __msan_unpoison() function."]
    #[doc = ""]
    #[doc = " The return value should always be zero."]
    pub fn halide_msan_annotate_memory_is_initialized(
        user_context: *mut ::std::os::raw::c_void,
        ptr: *const ::std::os::raw::c_void,
        len: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Mark the data pointed to by the halide_buffer_t as initialized (but *not* the halide_buffer_t itself),"]
    #[doc = " using halide_msan_annotate_memory_is_initialized() for marking."]
    #[doc = ""]
    #[doc = " The default implementation takes pains to only mark the active memory ranges"]
    #[doc = " (skipping padding), and sorting into ranges to always mark the smallest number of"]
    #[doc = " ranges, in monotonically increasing memory order."]
    #[doc = ""]
    #[doc = " Most client code should never need to replace the default implementation."]
    #[doc = ""]
    #[doc = " The return value should always be zero."]
    pub fn halide_msan_annotate_buffer_is_initialized(
        user_context: *mut ::std::os::raw::c_void,
        buffer: *mut halide_buffer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_msan_annotate_buffer_is_initialized_as_destructor(
        user_context: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
    );
}
#[doc = " There was no error. This is the value returned by Halide on success."]
pub const halide_error_code_t_halide_error_code_success: halide_error_code_t = 0;
#[doc = " An uncategorized error occurred. Refer to the string passed to halide_error."]
pub const halide_error_code_t_halide_error_code_generic_error: halide_error_code_t = -1;
#[doc = " A Func was given an explicit bound via Func::bound, but this"]
#[doc = " was not large enough to encompass the region that is used of"]
#[doc = " the Func by the rest of the pipeline."]
pub const halide_error_code_t_halide_error_code_explicit_bounds_too_small: halide_error_code_t = -2;
#[doc = " The elem_size field of a halide_buffer_t does not match the size in"]
#[doc = " bytes of the type of that ImageParam. Probable type mismatch."]
pub const halide_error_code_t_halide_error_code_bad_type: halide_error_code_t = -3;
#[doc = " A pipeline would access memory outside of the halide_buffer_t passed"]
#[doc = " in."]
pub const halide_error_code_t_halide_error_code_access_out_of_bounds: halide_error_code_t = -4;
#[doc = " A halide_buffer_t was given that spans more than 2GB of memory."]
pub const halide_error_code_t_halide_error_code_buffer_allocation_too_large: halide_error_code_t =
    -5;
#[doc = " A halide_buffer_t was given with extents that multiply to a number"]
#[doc = " greater than 2^31-1"]
pub const halide_error_code_t_halide_error_code_buffer_extents_too_large: halide_error_code_t = -6;
#[doc = " Applying explicit constraints on the size of an input or"]
#[doc = " output buffer shrank the size of that buffer below what will be"]
#[doc = " accessed by the pipeline."]
pub const halide_error_code_t_halide_error_code_constraints_make_required_region_smaller:
    halide_error_code_t = -7;
#[doc = " A constraint on a size or stride of an input or output buffer"]
#[doc = " was not met by the halide_buffer_t passed in."]
pub const halide_error_code_t_halide_error_code_constraint_violated: halide_error_code_t = -8;
#[doc = " A scalar parameter passed in was smaller than its minimum"]
#[doc = " declared value."]
pub const halide_error_code_t_halide_error_code_param_too_small: halide_error_code_t = -9;
#[doc = " A scalar parameter passed in was greater than its minimum"]
#[doc = " declared value."]
pub const halide_error_code_t_halide_error_code_param_too_large: halide_error_code_t = -10;
#[doc = " A call to halide_malloc returned NULL."]
pub const halide_error_code_t_halide_error_code_out_of_memory: halide_error_code_t = -11;
#[doc = " A halide_buffer_t pointer passed in was NULL."]
pub const halide_error_code_t_halide_error_code_buffer_argument_is_null: halide_error_code_t = -12;
#[doc = " debug_to_file failed to open or write to the specified"]
#[doc = " file."]
pub const halide_error_code_t_halide_error_code_debug_to_file_failed: halide_error_code_t = -13;
#[doc = " The Halide runtime encountered an error while trying to copy"]
#[doc = " from device to host. Turn on -debug in your target string to"]
#[doc = " see more details."]
pub const halide_error_code_t_halide_error_code_copy_to_host_failed: halide_error_code_t = -14;
#[doc = " The Halide runtime encountered an error while trying to copy"]
#[doc = " from host to device. Turn on -debug in your target string to"]
#[doc = " see more details."]
pub const halide_error_code_t_halide_error_code_copy_to_device_failed: halide_error_code_t = -15;
#[doc = " The Halide runtime encountered an error while trying to"]
#[doc = " allocate memory on device. Turn on -debug in your target string"]
#[doc = " to see more details."]
pub const halide_error_code_t_halide_error_code_device_malloc_failed: halide_error_code_t = -16;
#[doc = " The Halide runtime encountered an error while trying to"]
#[doc = " synchronize with a device. Turn on -debug in your target string"]
#[doc = " to see more details."]
pub const halide_error_code_t_halide_error_code_device_sync_failed: halide_error_code_t = -17;
#[doc = " The Halide runtime encountered an error while trying to free a"]
#[doc = " device allocation. Turn on -debug in your target string to see"]
#[doc = " more details."]
pub const halide_error_code_t_halide_error_code_device_free_failed: halide_error_code_t = -18;
#[doc = " Buffer has a non-zero device but no device interface, which"]
#[doc = " violates a Halide invariant."]
pub const halide_error_code_t_halide_error_code_no_device_interface: halide_error_code_t = -19;
#[doc = " An error occurred when attempting to initialize the Matlab"]
#[doc = " runtime."]
pub const halide_error_code_t_halide_error_code_matlab_init_failed: halide_error_code_t = -20;
#[doc = " The type of an mxArray did not match the expected type."]
pub const halide_error_code_t_halide_error_code_matlab_bad_param_type: halide_error_code_t = -21;
#[doc = " There is a bug in the Halide compiler."]
pub const halide_error_code_t_halide_error_code_internal_error: halide_error_code_t = -22;
#[doc = " The Halide runtime encountered an error while trying to launch"]
#[doc = " a GPU kernel. Turn on -debug in your target string to see more"]
#[doc = " details."]
pub const halide_error_code_t_halide_error_code_device_run_failed: halide_error_code_t = -23;
#[doc = " The Halide runtime encountered a host pointer that violated"]
#[doc = " the alignment set for it by way of a call to"]
#[doc = " set_host_alignment"]
pub const halide_error_code_t_halide_error_code_unaligned_host_ptr: halide_error_code_t = -24;
#[doc = " A fold_storage directive was used on a dimension that is not"]
#[doc = " accessed in a monotonically increasing or decreasing fashion."]
pub const halide_error_code_t_halide_error_code_bad_fold: halide_error_code_t = -25;
#[doc = " A fold_storage directive was used with a fold factor that was"]
#[doc = " too small to store all the values of a producer needed by the"]
#[doc = " consumer."]
pub const halide_error_code_t_halide_error_code_fold_factor_too_small: halide_error_code_t = -26;
#[doc = " User-specified require() expression was not satisfied."]
pub const halide_error_code_t_halide_error_code_requirement_failed: halide_error_code_t = -27;
#[doc = " At least one of the buffer's extents are negative."]
pub const halide_error_code_t_halide_error_code_buffer_extents_negative: halide_error_code_t = -28;
#[doc = " At least one of the buffer's extents are negative."]
pub const halide_error_code_t_halide_error_code_unused_29: halide_error_code_t = -29;
#[doc = " At least one of the buffer's extents are negative."]
pub const halide_error_code_t_halide_error_code_unused_30: halide_error_code_t = -30;
#[doc = " A specialize_fail() schedule branch was selected at runtime."]
pub const halide_error_code_t_halide_error_code_specialize_fail: halide_error_code_t = -31;
#[doc = " The Halide runtime encountered an error while trying to wrap a"]
#[doc = " native device handle.  Turn on -debug in your target string to"]
#[doc = " see more details."]
pub const halide_error_code_t_halide_error_code_device_wrap_native_failed: halide_error_code_t =
    -32;
#[doc = " The Halide runtime encountered an error while trying to detach"]
#[doc = " a native device handle.  Turn on -debug in your target string"]
#[doc = " to see more details."]
pub const halide_error_code_t_halide_error_code_device_detach_native_failed: halide_error_code_t =
    -33;
#[doc = " The host field on an input or output was null, the device"]
#[doc = " field was not zero, and the pipeline tries to use the buffer on"]
#[doc = " the host. You may be passing a GPU-only buffer to a pipeline"]
#[doc = " which is scheduled to use it on the CPU."]
pub const halide_error_code_t_halide_error_code_host_is_null: halide_error_code_t = -34;
#[doc = " A folded buffer was passed to an extern stage, but the region"]
#[doc = " touched wraps around the fold boundary."]
pub const halide_error_code_t_halide_error_code_bad_extern_fold: halide_error_code_t = -35;
#[doc = " Buffer has a non-null device_interface but device is 0, which"]
#[doc = " violates a Halide invariant."]
pub const halide_error_code_t_halide_error_code_device_interface_no_device: halide_error_code_t =
    -36;
#[doc = " Buffer has both host and device dirty bits set, which violates"]
#[doc = " a Halide invariant."]
pub const halide_error_code_t_halide_error_code_host_and_device_dirty: halide_error_code_t = -37;
#[doc = " The halide_buffer_t * passed to a halide runtime routine is"]
#[doc = " nullptr and this is not allowed."]
pub const halide_error_code_t_halide_error_code_buffer_is_null: halide_error_code_t = -38;
#[doc = " The Halide runtime encountered an error while trying to copy"]
#[doc = " from one buffer to another. Turn on -debug in your target"]
#[doc = " string to see more details."]
pub const halide_error_code_t_halide_error_code_device_buffer_copy_failed: halide_error_code_t =
    -39;
#[doc = " Attempted to make cropped/sliced alias of a buffer with a device"]
#[doc = " field, but the device_interface does not support cropping."]
pub const halide_error_code_t_halide_error_code_device_crop_unsupported: halide_error_code_t = -40;
#[doc = " Cropping/slicing a buffer failed for some other reason. Turn on -debug"]
#[doc = " in your target string."]
pub const halide_error_code_t_halide_error_code_device_crop_failed: halide_error_code_t = -41;
#[doc = " An operation on a buffer required an allocation on a"]
#[doc = " particular device interface, but a device allocation already"]
#[doc = " existed on a different device interface. Free the old one"]
#[doc = " first."]
pub const halide_error_code_t_halide_error_code_incompatible_device_interface: halide_error_code_t =
    -42;
#[doc = " The dimensions field of a halide_buffer_t does not match the dimensions of that ImageParam."]
pub const halide_error_code_t_halide_error_code_bad_dimensions: halide_error_code_t = -43;
#[doc = " A buffer with the device_dirty flag set was passed to a"]
#[doc = " pipeline compiled with no device backends enabled, so it"]
#[doc = " doesn't know how to copy the data back from device memory to"]
#[doc = " host memory. Either call copy_to_host before calling the Halide"]
#[doc = " pipeline, or enable the appropriate device backend."]
pub const halide_error_code_t_halide_error_code_device_dirty_with_no_device_support:
    halide_error_code_t = -44;
#[doc = " An explicit storage bound provided is too small to store"]
#[doc = " all the values produced by the function."]
pub const halide_error_code_t_halide_error_code_storage_bound_too_small: halide_error_code_t = -45;
#[doc = " The error codes that may be returned by a Halide pipeline."]
pub type halide_error_code_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = " A call into an extern stage for the purposes of bounds inference"]
    #[doc = " failed. Returns the error code given by the extern stage."]
    pub fn halide_error_bounds_inference_call_failed(
        user_context: *mut ::std::os::raw::c_void,
        extern_stage_name: *const ::std::os::raw::c_char,
        result: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A call to an extern stage failed. Returned the error code given by"]
    #[doc = " the extern stage."]
    pub fn halide_error_extern_stage_failed(
        user_context: *mut ::std::os::raw::c_void,
        extern_stage_name: *const ::std::os::raw::c_char,
        result: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_explicit_bounds_too_small(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        var_name: *const ::std::os::raw::c_char,
        min_bound: ::std::os::raw::c_int,
        max_bound: ::std::os::raw::c_int,
        min_required: ::std::os::raw::c_int,
        max_required: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_bad_type(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        type_given: u32,
        correct_type: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_bad_dimensions(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        dimensions_given: i32,
        correct_dimensions: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_access_out_of_bounds(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        dimension: ::std::os::raw::c_int,
        min_touched: ::std::os::raw::c_int,
        max_touched: ::std::os::raw::c_int,
        min_valid: ::std::os::raw::c_int,
        max_valid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_buffer_allocation_too_large(
        user_context: *mut ::std::os::raw::c_void,
        buffer_name: *const ::std::os::raw::c_char,
        allocation_size: u64,
        max_size: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_buffer_extents_negative(
        user_context: *mut ::std::os::raw::c_void,
        buffer_name: *const ::std::os::raw::c_char,
        dimension: ::std::os::raw::c_int,
        extent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_buffer_extents_too_large(
        user_context: *mut ::std::os::raw::c_void,
        buffer_name: *const ::std::os::raw::c_char,
        actual_size: i64,
        max_size: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_constraints_make_required_region_smaller(
        user_context: *mut ::std::os::raw::c_void,
        buffer_name: *const ::std::os::raw::c_char,
        dimension: ::std::os::raw::c_int,
        constrained_min: ::std::os::raw::c_int,
        constrained_extent: ::std::os::raw::c_int,
        required_min: ::std::os::raw::c_int,
        required_extent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_constraint_violated(
        user_context: *mut ::std::os::raw::c_void,
        var: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
        constrained_var: *const ::std::os::raw::c_char,
        constrained_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_param_too_small_i64(
        user_context: *mut ::std::os::raw::c_void,
        param_name: *const ::std::os::raw::c_char,
        val: i64,
        min_val: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_param_too_small_u64(
        user_context: *mut ::std::os::raw::c_void,
        param_name: *const ::std::os::raw::c_char,
        val: u64,
        min_val: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_param_too_small_f64(
        user_context: *mut ::std::os::raw::c_void,
        param_name: *const ::std::os::raw::c_char,
        val: f64,
        min_val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_param_too_large_i64(
        user_context: *mut ::std::os::raw::c_void,
        param_name: *const ::std::os::raw::c_char,
        val: i64,
        max_val: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_param_too_large_u64(
        user_context: *mut ::std::os::raw::c_void,
        param_name: *const ::std::os::raw::c_char,
        val: u64,
        max_val: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_param_too_large_f64(
        user_context: *mut ::std::os::raw::c_void,
        param_name: *const ::std::os::raw::c_char,
        val: f64,
        max_val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_out_of_memory(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_buffer_argument_is_null(
        user_context: *mut ::std::os::raw::c_void,
        buffer_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_debug_to_file_failed(
        user_context: *mut ::std::os::raw::c_void,
        func: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        error_code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_unaligned_host_ptr(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        alignment: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_host_is_null(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_bad_fold(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        var_name: *const ::std::os::raw::c_char,
        loop_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_bad_extern_fold(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        dim: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        extent: ::std::os::raw::c_int,
        valid_min: ::std::os::raw::c_int,
        fold_factor: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_fold_factor_too_small(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        var_name: *const ::std::os::raw::c_char,
        fold_factor: ::std::os::raw::c_int,
        loop_name: *const ::std::os::raw::c_char,
        required_extent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_requirement_failed(
        user_context: *mut ::std::os::raw::c_void,
        condition: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_specialize_fail(
        user_context: *mut ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_no_device_interface(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_device_interface_no_device(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_host_and_device_dirty(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_buffer_is_null(
        user_context: *mut ::std::os::raw::c_void,
        routine: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_device_dirty_with_no_device_support(
        user_context: *mut ::std::os::raw::c_void,
        buffer_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_storage_bound_too_small(
        user_context: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        var_name: *const ::std::os::raw::c_char,
        provided_size: ::std::os::raw::c_int,
        required_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn halide_error_device_crop_failed(
        user_context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Generate code that will run immediately inside the calling process."]
pub const halide_target_feature_t_halide_target_feature_jit: halide_target_feature_t = 0;
#[doc = "< Turn on debug info and output for runtime code."]
pub const halide_target_feature_t_halide_target_feature_debug: halide_target_feature_t = 1;
#[doc = "< Disable all runtime checks, for slightly tighter code."]
pub const halide_target_feature_t_halide_target_feature_no_asserts: halide_target_feature_t = 2;
#[doc = "< Disable the bounds querying functionality."]
pub const halide_target_feature_t_halide_target_feature_no_bounds_query: halide_target_feature_t =
    3;
#[doc = "< Use SSE 4.1 and earlier instructions. Only relevant on x86."]
pub const halide_target_feature_t_halide_target_feature_sse41: halide_target_feature_t = 4;
#[doc = "< Use AVX 1 instructions. Only relevant on x86."]
pub const halide_target_feature_t_halide_target_feature_avx: halide_target_feature_t = 5;
#[doc = "< Use AVX 2 instructions. Only relevant on x86."]
pub const halide_target_feature_t_halide_target_feature_avx2: halide_target_feature_t = 6;
#[doc = "< Enable x86 FMA instruction"]
pub const halide_target_feature_t_halide_target_feature_fma: halide_target_feature_t = 7;
#[doc = "< Enable x86 (AMD) FMA4 instruction set"]
pub const halide_target_feature_t_halide_target_feature_fma4: halide_target_feature_t = 8;
#[doc = "< Enable x86 16-bit float support"]
pub const halide_target_feature_t_halide_target_feature_f16c: halide_target_feature_t = 9;
#[doc = "< Generate code for ARMv7s. Only relevant for 32-bit ARM."]
pub const halide_target_feature_t_halide_target_feature_armv7s: halide_target_feature_t = 10;
#[doc = "< Avoid using NEON instructions. Only relevant for 32-bit ARM."]
pub const halide_target_feature_t_halide_target_feature_no_neon: halide_target_feature_t = 11;
#[doc = "< Use VSX instructions. Only relevant on POWERPC."]
pub const halide_target_feature_t_halide_target_feature_vsx: halide_target_feature_t = 12;
#[doc = "< Use POWER ISA 2.07 new instructions. Only relevant on POWERPC."]
pub const halide_target_feature_t_halide_target_feature_power_arch_2_07: halide_target_feature_t =
    13;
#[doc = "< Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi)"]
pub const halide_target_feature_t_halide_target_feature_cuda: halide_target_feature_t = 14;
#[doc = "< Enable CUDA compute capability 3.0 (Kepler)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability30: halide_target_feature_t =
    15;
#[doc = "< Enable CUDA compute capability 3.2 (Tegra K1)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability32: halide_target_feature_t =
    16;
#[doc = "< Enable CUDA compute capability 3.5 (Kepler)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability35: halide_target_feature_t =
    17;
#[doc = "< Enable CUDA compute capability 5.0 (Maxwell)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability50: halide_target_feature_t =
    18;
#[doc = "< Enable CUDA compute capability 6.1 (Pascal)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability61: halide_target_feature_t =
    19;
#[doc = "< Enable CUDA compute capability 7.0 (Volta)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability70: halide_target_feature_t =
    20;
#[doc = "< Enable CUDA compute capability 7.5 (Turing)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability75: halide_target_feature_t =
    21;
#[doc = "< Enable CUDA compute capability 8.0 (Ampere)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability80: halide_target_feature_t =
    22;
#[doc = "< Enable CUDA compute capability 8.6 (Ampere)"]
pub const halide_target_feature_t_halide_target_feature_cuda_capability86: halide_target_feature_t =
    23;
#[doc = "< Enable the OpenCL runtime."]
pub const halide_target_feature_t_halide_target_feature_opencl: halide_target_feature_t = 24;
#[doc = "< Enable double support on OpenCL targets"]
pub const halide_target_feature_t_halide_target_feature_cl_doubles: halide_target_feature_t = 25;
#[doc = "< Enable 64-bit atomics operations on OpenCL targets"]
pub const halide_target_feature_t_halide_target_feature_cl_atomic64: halide_target_feature_t = 26;
#[doc = "< Enable OpenGL Compute runtime."]
pub const halide_target_feature_t_halide_target_feature_openglcompute: halide_target_feature_t = 27;
#[doc = "< Generated code takes a user_context pointer as first argument"]
pub const halide_target_feature_t_halide_target_feature_user_context: halide_target_feature_t = 28;
#[doc = "< Generate a mexFunction compatible with Matlab mex libraries. See tools/mex_halide.m."]
pub const halide_target_feature_t_halide_target_feature_matlab: halide_target_feature_t = 29;
#[doc = "< Launch a sampling profiler alongside the Halide pipeline that monitors and reports the runtime used by each Func"]
pub const halide_target_feature_t_halide_target_feature_profile: halide_target_feature_t = 30;
#[doc = "< Do not include a copy of the Halide runtime in any generated object file or assembly"]
pub const halide_target_feature_t_halide_target_feature_no_runtime: halide_target_feature_t = 31;
#[doc = "< Enable the (Apple) Metal runtime."]
pub const halide_target_feature_t_halide_target_feature_metal: halide_target_feature_t = 32;
#[doc = "< Generate C++ mangled names for result function, et al"]
pub const halide_target_feature_t_halide_target_feature_c_plus_plus_mangling:
    halide_target_feature_t = 33;
#[doc = "< Enable 64-bit buffer indexing to support buffers > 2GB. Ignored if bits != 64."]
pub const halide_target_feature_t_halide_target_feature_large_buffers: halide_target_feature_t = 34;
#[doc = "< Enable HVX 128 byte mode."]
pub const halide_target_feature_t_halide_target_feature_hvx_128: halide_target_feature_t = 35;
#[doc = "< Enable Hexagon v62 architecture."]
pub const halide_target_feature_t_halide_target_feature_hvx_v62: halide_target_feature_t = 36;
#[doc = "< On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors."]
pub const halide_target_feature_t_halide_target_feature_fuzz_float_stores: halide_target_feature_t =
    37;
#[doc = "< Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats."]
pub const halide_target_feature_t_halide_target_feature_soft_float_abi: halide_target_feature_t =
    38;
#[doc = "< Enable hooks for MSAN support."]
pub const halide_target_feature_t_halide_target_feature_msan: halide_target_feature_t = 39;
#[doc = "< Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See https://en.wikipedia.org/wiki/AVX-512 for a description of each AVX subset."]
pub const halide_target_feature_t_halide_target_feature_avx512: halide_target_feature_t = 40;
#[doc = "< Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER."]
pub const halide_target_feature_t_halide_target_feature_avx512_knl: halide_target_feature_t = 41;
#[doc = "< Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors."]
pub const halide_target_feature_t_halide_target_feature_avx512_skylake: halide_target_feature_t =
    42;
#[doc = "< Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI."]
pub const halide_target_feature_t_halide_target_feature_avx512_cannonlake: halide_target_feature_t =
    43;
#[doc = "< Enable the AVX512 features supported by Sapphire Rapids processors. This include all of the Cannonlake features, plus AVX512-VNNI and AVX512-BF16."]
pub const halide_target_feature_t_halide_target_feature_avx512_sapphirerapids:
    halide_target_feature_t = 44;
#[doc = "< Deprecated"]
pub const halide_target_feature_t_halide_target_feature_hvx_use_shared_object:
    halide_target_feature_t = 45;
#[doc = "< Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func."]
pub const halide_target_feature_t_halide_target_feature_trace_loads: halide_target_feature_t = 46;
#[doc = "< Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func."]
pub const halide_target_feature_t_halide_target_feature_trace_stores: halide_target_feature_t = 47;
#[doc = "< Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func."]
pub const halide_target_feature_t_halide_target_feature_trace_realizations:
    halide_target_feature_t = 48;
#[doc = "< Trace the pipeline."]
pub const halide_target_feature_t_halide_target_feature_trace_pipeline: halide_target_feature_t =
    49;
#[doc = "< Enable Hexagon v65 architecture."]
pub const halide_target_feature_t_halide_target_feature_hvx_v65: halide_target_feature_t = 50;
#[doc = "< Enable Hexagon v66 architecture."]
pub const halide_target_feature_t_halide_target_feature_hvx_v66: halide_target_feature_t = 51;
#[doc = "< Enable half support on OpenCL targets"]
pub const halide_target_feature_t_halide_target_feature_cl_half: halide_target_feature_t = 52;
#[doc = "< Turn off all non-IEEE floating-point optimization. Currently applies only to LLVM targets."]
pub const halide_target_feature_t_halide_target_feature_strict_float: halide_target_feature_t = 53;
#[doc = "< Enable hooks for TSAN support."]
pub const halide_target_feature_t_halide_target_feature_tsan: halide_target_feature_t = 54;
#[doc = "< Enable hooks for ASAN support."]
pub const halide_target_feature_t_halide_target_feature_asan: halide_target_feature_t = 55;
#[doc = "< Enable Direct3D 12 Compute runtime."]
pub const halide_target_feature_t_halide_target_feature_d3d12compute: halide_target_feature_t = 56;
#[doc = "< Insert assertions for promises."]
pub const halide_target_feature_t_halide_target_feature_check_unsafe_promises:
    halide_target_feature_t = 57;
#[doc = "< Enable Hexagon DMA buffers."]
pub const halide_target_feature_t_halide_target_feature_hexagon_dma: halide_target_feature_t = 58;
#[doc = "< Emulate clang -fembed-bitcode flag."]
pub const halide_target_feature_t_halide_target_feature_embed_bitcode: halide_target_feature_t = 59;
#[doc = "< Enable loop vectorization + unrolling in LLVM. Overrides halide_target_feature_disable_llvm_loop_opt. (Ignored for non-LLVM targets.)"]
pub const halide_target_feature_t_halide_target_feature_enable_llvm_loop_opt:
    halide_target_feature_t = 60;
#[doc = "< Disable loop vectorization + unrolling in LLVM. (Ignored for non-LLVM targets.)"]
pub const halide_target_feature_t_halide_target_feature_disable_llvm_loop_opt:
    halide_target_feature_t = 61;
#[doc = "< Enable +simd128 instructions for WebAssembly codegen."]
pub const halide_target_feature_t_halide_target_feature_wasm_simd128: halide_target_feature_t = 62;
#[doc = "< Enable +sign-ext instructions for WebAssembly codegen."]
pub const halide_target_feature_t_halide_target_feature_wasm_signext: halide_target_feature_t = 63;
#[doc = "< Enable saturating (nontrapping) float-to-int instructions for WebAssembly codegen."]
pub const halide_target_feature_t_halide_target_feature_wasm_sat_float_to_int:
    halide_target_feature_t = 64;
#[doc = "< Enable use of threads in WebAssembly codegen. Requires the use of a wasm runtime that provides pthread-compatible wrappers (typically, Emscripten with the -pthreads flag). Unsupported under WASI."]
pub const halide_target_feature_t_halide_target_feature_wasm_threads: halide_target_feature_t = 65;
#[doc = "< Enable +bulk-memory instructions for WebAssembly codegen."]
pub const halide_target_feature_t_halide_target_feature_wasm_bulk_memory: halide_target_feature_t =
    66;
#[doc = "< Enable ARM Scalable Vector Extensions"]
pub const halide_target_feature_t_halide_target_feature_sve: halide_target_feature_t = 67;
#[doc = "< Enable ARM Scalable Vector Extensions v2"]
pub const halide_target_feature_t_halide_target_feature_sve2: halide_target_feature_t = 68;
#[doc = "< Force use of EGL support."]
pub const halide_target_feature_t_halide_target_feature_egl: halide_target_feature_t = 69;
#[doc = "< Enable ARMv8.2-a dotprod extension (i.e. udot and sdot instructions)"]
pub const halide_target_feature_t_halide_target_feature_arm_dot_prod: halide_target_feature_t = 70;
#[doc = "< Enable ARMv8.2-a half-precision floating point data processing"]
pub const halide_target_feature_t_halide_target_feature_arm_fp16: halide_target_feature_t = 71;
#[doc = "< Use the LLVM large code model to compile"]
pub const halide_target_feature_t_halide_llvm_large_code_model: halide_target_feature_t = 72;
#[doc = "< Enable RISCV \"V\" Vector Extension"]
pub const halide_target_feature_t_halide_target_feature_rvv: halide_target_feature_t = 73;
#[doc = "< Enable ARMv8.1-a instructions"]
pub const halide_target_feature_t_halide_target_feature_armv81a: halide_target_feature_t = 74;
#[doc = "< Enable hooks for SanitizerCoverage support."]
pub const halide_target_feature_t_halide_target_feature_sanitizer_coverage:
    halide_target_feature_t = 75;
#[doc = "< A sentinel. Every target is considered to have this feature, and setting this feature does nothing."]
pub const halide_target_feature_t_halide_target_feature_end: halide_target_feature_t = 76;
#[doc = " Optional features a compilation Target can have."]
#[doc = " Be sure to keep this in sync with the Feature enum in Target.h and the implementation of"]
#[doc = " get_runtime_compatible_target in Target.cpp if you add a new feature."]
pub type halide_target_feature_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn halide_can_use_target_features(
        count: ::std::os::raw::c_int,
        features: *const u64,
    ) -> ::std::os::raw::c_int;
}
pub type halide_can_use_target_features_t = ::std::option::Option<
    unsafe extern "C" fn(
        count: ::std::os::raw::c_int,
        features: *const u64,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn halide_set_custom_can_use_target_features(
        arg1: halide_can_use_target_features_t,
    ) -> halide_can_use_target_features_t;
}
extern "C" {
    #[doc = " This is the default implementation of halide_can_use_target_features; it is provided"]
    #[doc = " for convenience of user code that may wish to extend halide_can_use_target_features"]
    #[doc = " but continue providing existing support, e.g."]
    #[doc = ""]
    #[doc = "     int halide_can_use_target_features(int count, const uint64_t *features) {"]
    #[doc = "          if (features[halide_target_somefeature >> 6] & (1LL << (halide_target_somefeature & 63))) {"]
    #[doc = "              if (!can_use_somefeature()) {"]
    #[doc = "                  return 0;"]
    #[doc = "              }"]
    #[doc = "          }"]
    #[doc = "          return halide_default_can_use_target_features(count, features);"]
    #[doc = "     }"]
    pub fn halide_default_can_use_target_features(
        count: ::std::os::raw::c_int,
        features: *const u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_dimension_t {
    pub min: i32,
    pub extent: i32,
    pub stride: i32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_halide_dimension_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_dimension_t>(),
        16usize,
        concat!("Size of: ", stringify!(halide_dimension_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_dimension_t>(),
        4usize,
        concat!("Alignment of ", stringify!(halide_dimension_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_dimension_t>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_dimension_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_dimension_t>())).extent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_dimension_t),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_dimension_t>())).stride as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_dimension_t),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_dimension_t>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_dimension_t),
            "::",
            stringify!(flags)
        )
    );
}
pub const halide_buffer_flags_halide_buffer_flag_host_dirty: halide_buffer_flags = 1;
pub const halide_buffer_flags_halide_buffer_flag_device_dirty: halide_buffer_flags = 2;
pub type halide_buffer_flags = ::std::os::raw::c_uint;
#[doc = " \\file"]
#[doc = ""]
#[doc = " This file declares the routines used by Halide internally in its"]
#[doc = " runtime. On platforms that support weak linking, these can be"]
#[doc = " replaced with user-defined versions by defining an extern \"C\""]
#[doc = " function with the same name and signature."]
#[doc = ""]
#[doc = " When doing Just In Time (JIT) compilation members of"]
#[doc = " some_pipeline_or_func.jit_handlers() must be replaced instead. The"]
#[doc = " corresponding methods are documented below."]
#[doc = ""]
#[doc = " All of these functions take a \"void *user_context\" parameter as their"]
#[doc = " first argument; if the Halide kernel that calls back to any of these"]
#[doc = " functions has been compiled with the UserContext feature set on its Target,"]
#[doc = " then the value of that pointer passed from the code that calls the"]
#[doc = " Halide kernel is piped through to the function."]
#[doc = ""]
#[doc = " Some of these are also useful to call when using the default"]
#[doc = " implementation. E.g. halide_shutdown_thread_pool."]
#[doc = ""]
#[doc = " Note that even on platforms with weak linking, some linker setups"]
#[doc = " may not respect the override you provide. E.g. if the override is"]
#[doc = " in a shared library and the halide object files are linked directly"]
#[doc = " into the output, the builtin versions of the runtime functions will"]
#[doc = " be called. See your linker documentation for more details. On"]
#[doc = " Linux, LD_DYNAMIC_WEAK=1 may help."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_buffer_t {
    #[doc = " A device-handle for e.g. GPU memory used to back this buffer."]
    pub device: u64,
    #[doc = " The interface used to interpret the above handle."]
    pub device_interface: *const halide_device_interface_t,
    #[doc = " A pointer to the start of the data in main memory. In terms of"]
    #[doc = " the Halide coordinate system, this is the address of the min"]
    #[doc = " coordinates (defined below)."]
    pub host: *mut u8,
    #[doc = " flags with various meanings."]
    pub flags: u64,
    #[doc = " The type of each buffer element."]
    pub type_: halide_type_t,
    #[doc = " The dimensionality of the buffer."]
    pub dimensions: i32,
    #[doc = " The shape of the buffer. Halide does not own this array - you"]
    #[doc = " must manage the memory for it yourself."]
    pub dim: *mut halide_dimension_t,
    #[doc = " Pads the buffer up to a multiple of 8 bytes"]
    pub padding: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_halide_buffer_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_buffer_t>(),
        56usize,
        concat!("Size of: ", stringify!(halide_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_buffer_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_buffer_t>())).device_interface as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(device_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).host as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).dimensions as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(dimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).dim as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(dim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_buffer_t>())).padding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_buffer_t),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " halide_scalar_value_t is a simple union able to represent all the well-known"]
#[doc = " scalar values in a filter argument. Note that it isn't tagged with a type;"]
#[doc = " you must ensure you know the proper type before accessing. Most user"]
#[doc = " code will never need to create instances of this struct; its primary use"]
#[doc = " is to hold def/min/max values in a halide_filter_argument_t. (Note that"]
#[doc = " this is conceptually just a union; it's wrapped in a struct to ensure"]
#[doc = " that it doesn't get anonymized by LLVM.)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct halide_scalar_value_t {
    pub u: halide_scalar_value_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union halide_scalar_value_t__bindgen_ty_1 {
    pub b: bool,
    pub i8_: i8,
    pub i16_: i16,
    pub i32_: i32,
    pub i64_: i64,
    pub u8_: u8,
    pub u16_: u16,
    pub u32_: u32,
    pub u64_: u64,
    pub f32_: f32,
    pub f64_: f64,
    pub handle: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_halide_scalar_value_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<halide_scalar_value_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(halide_scalar_value_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_scalar_value_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(halide_scalar_value_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).b as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).i8_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(i8_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).i16_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).i32_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).i64_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).u8_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).u16_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).u32_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).u64_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).f32_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(f32_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).f64_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_scalar_value_t__bindgen_ty_1>())).handle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout_halide_scalar_value_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_scalar_value_t>(),
        8usize,
        concat!("Size of: ", stringify!(halide_scalar_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_scalar_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_scalar_value_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_scalar_value_t>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_scalar_value_t),
            "::",
            stringify!(u)
        )
    );
}
pub const halide_argument_kind_t_halide_argument_kind_input_scalar: halide_argument_kind_t = 0;
pub const halide_argument_kind_t_halide_argument_kind_input_buffer: halide_argument_kind_t = 1;
pub const halide_argument_kind_t_halide_argument_kind_output_buffer: halide_argument_kind_t = 2;
pub type halide_argument_kind_t = ::std::os::raw::c_uint;
#[doc = " Obsolete version of halide_filter_argument_t; only present in"]
#[doc = " code that wrote halide_filter_metadata_t version 0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_filter_argument_t_v0 {
    pub name: *const ::std::os::raw::c_char,
    pub kind: i32,
    pub dimensions: i32,
    pub type_: halide_type_t,
    pub def: *const halide_scalar_value_t,
    pub min: *const halide_scalar_value_t,
    pub max: *const halide_scalar_value_t,
}
#[test]
fn bindgen_test_layout_halide_filter_argument_t_v0() {
    assert_eq!(
        ::std::mem::size_of::<halide_filter_argument_t_v0>(),
        48usize,
        concat!("Size of: ", stringify!(halide_filter_argument_t_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_filter_argument_t_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_filter_argument_t_v0))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).kind as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).dimensions as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(dimensions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).type_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).def as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_argument_t_v0>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t_v0),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " halide_filter_argument_t is essentially a plain-C-struct equivalent to"]
#[doc = " Halide::Argument; most user code will never need to create one."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_filter_argument_t {
    pub name: *const ::std::os::raw::c_char,
    pub kind: i32,
    pub dimensions: i32,
    pub type_: halide_type_t,
    pub scalar_def: *const halide_scalar_value_t,
    pub scalar_min: *const halide_scalar_value_t,
    pub scalar_max: *const halide_scalar_value_t,
    pub scalar_estimate: *const halide_scalar_value_t,
    pub buffer_estimates: *const *const i64,
}
#[test]
fn bindgen_test_layout_halide_filter_argument_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_filter_argument_t>(),
        64usize,
        concat!("Size of: ", stringify!(halide_filter_argument_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_filter_argument_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_filter_argument_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_argument_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_argument_t>())).kind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t>())).dimensions as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(dimensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_argument_t>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t>())).scalar_def as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(scalar_def)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t>())).scalar_min as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(scalar_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t>())).scalar_max as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(scalar_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t>())).scalar_estimate as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(scalar_estimate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_argument_t>())).buffer_estimates as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_argument_t),
            "::",
            stringify!(buffer_estimates)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_filter_metadata_t {
    #[doc = " version of this metadata; currently always 1."]
    pub version: i32,
    #[doc = " The number of entries in the arguments field. This is always >= 1."]
    pub num_arguments: i32,
    #[doc = " An array of the filters input and output arguments; this will never be"]
    #[doc = " null. The order of arguments is not guaranteed (input and output arguments"]
    #[doc = " may come in any order); however, it is guaranteed that all arguments"]
    #[doc = " will have a unique name within a given filter."]
    pub arguments: *const halide_filter_argument_t,
    #[doc = " The Target for which the filter was compiled. This is always"]
    #[doc = " a canonical Target string (ie a product of Target::to_string)."]
    pub target: *const ::std::os::raw::c_char,
    #[doc = " The function name of the filter."]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_halide_filter_metadata_t() {
    assert_eq!(
        ::std::mem::size_of::<halide_filter_metadata_t>(),
        32usize,
        concat!("Size of: ", stringify!(halide_filter_metadata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_filter_metadata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_filter_metadata_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_metadata_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_metadata_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_metadata_t>())).num_arguments as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_metadata_t),
            "::",
            stringify!(num_arguments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_filter_metadata_t>())).arguments as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_metadata_t),
            "::",
            stringify!(arguments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_metadata_t>())).target as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_metadata_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_filter_metadata_t>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_filter_metadata_t),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = " halide_register_argv_and_metadata() is a **user-defined** function that"]
    #[doc = " must be provided in order to use the registration.cc files produced"]
    #[doc = " by Generators when the 'registration' output is requested. Each registration.cc"]
    #[doc = " file provides a static initializer that calls this function with the given"]
    #[doc = " filter's argv-call variant, its metadata, and (optionally) and additional"]
    #[doc = " textual data that the build system chooses to tack on for its own purposes."]
    #[doc = " Note that this will be called at static-initializer time (i.e., before"]
    #[doc = " main() is called), and in an unpredictable order. Note that extra_key_value_pairs"]
    #[doc = " may be nullptr; if it's not null, it's expected to be a null-terminated list"]
    #[doc = " of strings, with an even number of entries."]
    pub fn halide_register_argv_and_metadata(
        filter_argv_call: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        filter_metadata: *const halide_filter_metadata_t,
        extra_key_value_pairs: *const *const ::std::os::raw::c_char,
    );
}
#[doc = " Per-Func state tracked by the sampling profiler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_profiler_func_stats {
    #[doc = " Total time taken evaluating this Func (in nanoseconds)."]
    pub time: u64,
    #[doc = " The current memory allocation of this Func."]
    pub memory_current: u64,
    #[doc = " The peak memory allocation of this Func."]
    pub memory_peak: u64,
    #[doc = " The total memory allocation of this Func."]
    pub memory_total: u64,
    #[doc = " The peak stack allocation of this Func's threads."]
    pub stack_peak: u64,
    #[doc = " The average number of thread pool worker threads active while computing this Func."]
    pub active_threads_numerator: u64,
    #[doc = " The average number of thread pool worker threads active while computing this Func."]
    pub active_threads_denominator: u64,
    #[doc = " The name of this Func. A global constant string."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The total number of memory allocation of this Func."]
    pub num_allocs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_halide_profiler_func_stats() {
    assert_eq!(
        ::std::mem::size_of::<halide_profiler_func_stats>(),
        72usize,
        concat!("Size of: ", stringify!(halide_profiler_func_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_profiler_func_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_profiler_func_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_profiler_func_stats>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).memory_current as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(memory_current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).memory_peak as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(memory_peak)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).memory_total as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(memory_total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).stack_peak as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(stack_peak)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).active_threads_numerator
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(active_threads_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).active_threads_denominator
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(active_threads_denominator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_profiler_func_stats>())).name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_func_stats>())).num_allocs as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_func_stats),
            "::",
            stringify!(num_allocs)
        )
    );
}
#[doc = " Per-pipeline state tracked by the sampling profiler. These exist"]
#[doc = " in a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_profiler_pipeline_stats {
    #[doc = " Total time spent inside this pipeline (in nanoseconds)"]
    pub time: u64,
    #[doc = " The current memory allocation of funcs in this pipeline."]
    pub memory_current: u64,
    #[doc = " The peak memory allocation of funcs in this pipeline."]
    pub memory_peak: u64,
    #[doc = " The total memory allocation of funcs in this pipeline."]
    pub memory_total: u64,
    #[doc = " The average number of thread pool worker threads doing useful"]
    #[doc = " work while computing this pipeline."]
    pub active_threads_numerator: u64,
    #[doc = " The average number of thread pool worker threads doing useful"]
    #[doc = " work while computing this pipeline."]
    pub active_threads_denominator: u64,
    #[doc = " The name of this pipeline. A global constant string."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " An array containing states for each Func in this pipeline."]
    pub funcs: *mut halide_profiler_func_stats,
    #[doc = " The next pipeline_stats pointer. It's a void * because types"]
    #[doc = " in the Halide runtime may not currently be recursive."]
    pub next: *mut ::std::os::raw::c_void,
    #[doc = " The number of funcs in this pipeline."]
    pub num_funcs: ::std::os::raw::c_int,
    #[doc = " An internal base id used to identify the funcs in this pipeline."]
    pub first_func_id: ::std::os::raw::c_int,
    #[doc = " The number of times this pipeline has been run."]
    pub runs: ::std::os::raw::c_int,
    #[doc = " The total number of samples taken inside of this pipeline."]
    pub samples: ::std::os::raw::c_int,
    #[doc = " The total number of memory allocation of funcs in this pipeline."]
    pub num_allocs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_halide_profiler_pipeline_stats() {
    assert_eq!(
        ::std::mem::size_of::<halide_profiler_pipeline_stats>(),
        96usize,
        concat!("Size of: ", stringify!(halide_profiler_pipeline_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_profiler_pipeline_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_profiler_pipeline_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).time as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).memory_current as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(memory_current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).memory_peak as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(memory_peak)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).memory_total as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(memory_total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).active_threads_numerator
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(active_threads_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).active_threads_denominator
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(active_threads_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).name as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).funcs as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).next as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).num_funcs as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(num_funcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).first_func_id as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(first_func_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).runs as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(runs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).samples as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_pipeline_stats>())).num_allocs as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_pipeline_stats),
            "::",
            stringify!(num_allocs)
        )
    );
}
#[doc = " The global state of the profiler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_profiler_state {
    #[doc = " Guards access to the fields below. If not locked, the sampling"]
    #[doc = " profiler thread is free to modify things below (including"]
    #[doc = " reordering the linked list of pipeline stats)."]
    pub lock: halide_mutex,
    #[doc = " The amount of time the profiler thread sleeps between samples"]
    #[doc = " in milliseconds. Defaults to 1"]
    pub sleep_time: ::std::os::raw::c_int,
    #[doc = " An internal id used for bookkeeping."]
    pub first_free_id: ::std::os::raw::c_int,
    #[doc = " The id of the current running Func. Set by the pipeline, read"]
    #[doc = " periodically by the profiler thread."]
    pub current_func: ::std::os::raw::c_int,
    #[doc = " The number of threads currently doing work."]
    pub active_threads: ::std::os::raw::c_int,
    #[doc = " A linked list of stats gathered for each pipeline."]
    pub pipelines: *mut halide_profiler_pipeline_stats,
    #[doc = " Retrieve remote profiler state. Used so that the sampling"]
    #[doc = " profiler can follow along with execution that occurs elsewhere,"]
    #[doc = " e.g. on a DSP. If null, it reads from the int above instead."]
    pub get_remote_profiler_state: ::std::option::Option<
        unsafe extern "C" fn(
            func: *mut ::std::os::raw::c_int,
            active_workers: *mut ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Sampling thread reference to be joined at shutdown."]
    pub sampling_thread: *mut halide_thread,
}
#[test]
fn bindgen_test_layout_halide_profiler_state() {
    assert_eq!(
        ::std::mem::size_of::<halide_profiler_state>(),
        48usize,
        concat!("Size of: ", stringify!(halide_profiler_state))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_profiler_state>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_profiler_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_profiler_state>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_state>())).sleep_time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(sleep_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_state>())).first_free_id as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(first_free_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_state>())).current_func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(current_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_state>())).active_threads as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(active_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<halide_profiler_state>())).pipelines as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(pipelines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_state>())).get_remote_profiler_state as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(get_remote_profiler_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_profiler_state>())).sampling_thread as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_profiler_state),
            "::",
            stringify!(sampling_thread)
        )
    );
}
#[doc = " current_func takes on this value when not inside Halide code"]
pub const halide_profiler_outside_of_halide: ::std::os::raw::c_int = -1;
#[doc = " Set current_func to this value to tell the profiling thread to"]
#[doc = " halt. It will start up again next time you run a pipeline with"]
#[doc = " profiling enabled."]
pub const halide_profiler_please_stop: ::std::os::raw::c_int = -2;
#[doc = " Profiler func ids with special meanings."]
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Get a pointer to the global profiler state for programmatic"]
    #[doc = " inspection. Lock it before using to pause the profiler."]
    pub fn halide_profiler_get_state() -> *mut halide_profiler_state;
}
extern "C" {
    #[doc = " Get a pointer to the pipeline state associated with pipeline_name."]
    #[doc = " This function grabs the global profiler state's lock on entry."]
    pub fn halide_profiler_get_pipeline_state(
        pipeline_name: *const ::std::os::raw::c_char,
    ) -> *mut halide_profiler_pipeline_stats;
}
extern "C" {
    #[doc = " Reset profiler state cheaply. May leave threads running or some"]
    #[doc = " memory allocated but all accumluated statistics are reset."]
    #[doc = " WARNING: Do NOT call this method while any halide pipeline is"]
    #[doc = " running; halide_profiler_memory_allocate/free and"]
    #[doc = " halide_profiler_stack_peak_update update the profiler pipeline's"]
    #[doc = " state without grabbing the global profiler state's lock."]
    pub fn halide_profiler_reset();
}
extern "C" {
    #[doc = " Reset all profiler state."]
    #[doc = " WARNING: Do NOT call this method while any halide pipeline is"]
    #[doc = " running; halide_profiler_memory_allocate/free and"]
    #[doc = " halide_profiler_stack_peak_update update the profiler pipeline's"]
    #[doc = " state without grabbing the global profiler state's lock."]
    pub fn halide_profiler_shutdown();
}
extern "C" {
    #[doc = " Print out timing statistics for everything run since the last"]
    #[doc = " reset. Also happens at process exit."]
    pub fn halide_profiler_report(user_context: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Read bits representing a half precision floating point number and return"]
    #[doc = "  the float that represents the same value"]
    pub fn halide_float16_bits_to_float(arg1: u16) -> f32;
}
extern "C" {
    #[doc = " Read bits representing a half precision floating point number and return"]
    #[doc = "  the double that represents the same value"]
    pub fn halide_float16_bits_to_double(arg1: u16) -> f64;
}
extern "C" {
    #[doc = " Tell Halide whether or not it is permitted to hold onto device"]
    #[doc = " allocations to service future requests instead of returning them"]
    #[doc = " eagerly to the underlying device API. Many device allocators are"]
    #[doc = " quite slow, so it can be beneficial to set this to true. The"]
    #[doc = " default value for now is false."]
    #[doc = ""]
    #[doc = " Note that if enabled, the eviction policy is very simplistic. The"]
    #[doc = " 32 most-recently used allocations are preserved, regardless of"]
    #[doc = " their size. Additionally, if a call to cuMalloc results in an"]
    #[doc = " out-of-memory error, the entire cache is flushed and the allocation"]
    #[doc = " is retried. See https://github.com/halide/Halide/issues/4093"]
    #[doc = ""]
    #[doc = " If set to false, releases all unused device allocations back to the"]
    #[doc = " underlying device APIs. For finer-grained control, see specific"]
    #[doc = " methods in each device api runtime."]
    pub fn halide_reuse_device_allocations(
        user_context: *mut ::std::os::raw::c_void,
        arg1: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines whether on device_free the memory is returned"]
    #[doc = " immediately to the device API, or placed on a free list for future"]
    #[doc = " use. Override and switch based on the user_context for"]
    #[doc = " finer-grained control. By default just returns the value most"]
    #[doc = " recently set by the method above."]
    pub fn halide_can_reuse_device_allocations(user_context: *mut ::std::os::raw::c_void) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct halide_device_allocation_pool {
    pub release_unused: ::std::option::Option<
        unsafe extern "C" fn(user_context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub next: *mut halide_device_allocation_pool,
}
#[test]
fn bindgen_test_layout_halide_device_allocation_pool() {
    assert_eq!(
        ::std::mem::size_of::<halide_device_allocation_pool>(),
        16usize,
        concat!("Size of: ", stringify!(halide_device_allocation_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<halide_device_allocation_pool>(),
        8usize,
        concat!("Alignment of ", stringify!(halide_device_allocation_pool))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_allocation_pool>())).release_unused as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_allocation_pool),
            "::",
            stringify!(release_unused)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<halide_device_allocation_pool>())).next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(halide_device_allocation_pool),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Register a callback to be informed when"]
    #[doc = " halide_reuse_device_allocations(false) is called, and all unused"]
    #[doc = " device allocations must be released. The object passed should have"]
    #[doc = " global lifetime, and its next field will be clobbered."]
    pub fn halide_register_device_allocation_pool(arg1: *mut halide_device_allocation_pool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
